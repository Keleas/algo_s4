/****************************************************************************

–ó–∞–¥–∞—á–∞ A –≤ –∫–æ–Ω—Ç–µ—Å—Ç–µ.

–î–∞–Ω –Ω–µ–æ—Ä–∏–µ–Ω—Ç–∏—Ä–æ–≤–∞–Ω–Ω—ã–π —Å–≤—è–∑–Ω—ã–π –≥—Ä–∞—Ñ. –¢—Ä–µ–±—É–µ—Ç—Å—è –Ω–∞–π—Ç–∏ –≤–µ—Å –º–∏–Ω–∏–º–∞–ª—å–Ω–æ–≥–æ –æ—Å—Ç–æ–≤–Ω–æ–≥–æ –¥–µ—Ä–µ–≤–∞ –≤ —ç—Ç–æ–º –≥—Ä–∞—Ñ–µ.
–í–∞—Ä–∏–∞–Ω—Ç 1. –° –ø–æ–º–æ—â—å—é –∞–ª–≥–æ—Ä–∏—Ç–º–∞ –ü—Ä–∏–º–∞.
–í–∞—Ä–∏–∞–Ω—Ç 2. –° –ø–æ–º–æ—â—å—é –∞–ª–≥–æ—Ä–∏—Ç–º–∞ –ö—Ä—É—Å–∫–∞–ª–∞.
–í–∞—Ä–∏–∞–Ω—Ç 3. –° –ø–æ–º–æ—â—å—é –∞–ª–≥–æ—Ä–∏—Ç–º–∞ –ë–æ—Ä—É–≤–∫–∏.
–û–¥–∏–Ω –≤–∞—Ä–∏–∞–Ω—Ç –Ω–∞ –≤—Å–µ—Ö –Ω–µ –±—Ä–∞—Ç—å =)

*–§–æ—Ä–º–∞—Ç –≤—Ö–æ–¥–Ω–æ–≥–æ —Ñ–∞–π–ª–∞*
–ü–µ—Ä–≤–∞—è —Å—Ç—Ä–æ–∫–∞ –≤—Ö–æ–¥–Ω–æ–≥–æ —Ñ–∞–π–ª–∞ —Å–æ–¥–µ—Ä–∂–∏—Ç –¥–≤–∞ –Ω–∞—Ç—É—Ä–∞–ª—å–Ω—ã—Ö —á–∏—Å–ª–∞ ùëõ –∏ ùëö ‚Äî –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –≤–µ—Ä—à–∏–Ω –∏ —Ä–µ–±–µ—Ä –≥—Ä–∞—Ñ–∞ —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤–µ–Ω–Ω–æ (1 ‚â§ n ‚â§ 20000, 0 ‚â§ m ‚â§ 100000).
–°–ª–µ–¥—É—é—â–∏–µ ùëö —Å—Ç—Ä–æ–∫ —Å–æ–¥–µ—Ä–∂–∞—Ç –æ–ø–∏—Å–∞–Ω–∏–µ —Ä–µ–±–µ—Ä –ø–æ –æ–¥–Ω–æ–º—É –Ω–∞ —Å—Ç—Ä–æ–∫–µ.
–†–µ–±—Ä–æ –Ω–æ–º–µ—Ä ùëñ –æ–ø–∏—Å—ã–≤–∞–µ—Ç—Å—è —Ç—Ä–µ–º—è –Ω–∞—Ç—É—Ä–∞–ª—å–Ω—ã–º–∏ —á–∏—Å–ª–∞–º–∏ ùëèùëñ, ùëíùëñ –∏ ùë§ùëñ ‚Äî –Ω–æ–º–µ—Ä–∞ –∫–æ–Ω—Ü–æ–≤ —Ä–µ–±—Ä–∞ –∏ –µ–≥–æ –≤–µ—Å —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤–µ–Ω–Ω–æ (1 ‚â§ ùëèùëñ, ùëíùëñ ‚â§ ùëõ, 0 ‚â§ ùë§ùëñ ‚â§ 100000).

*–§–æ—Ä–º–∞—Ç –≤—ã—Ö–æ–¥–Ω–æ–≥–æ —Ñ–∞–π–ª–∞*
–í—ã–≤–µ–¥–∏—Ç–µ –µ–¥–∏–Ω—Å—Ç–≤–µ–Ω–Ω–æ–µ —Ü–µ–ª–æ–µ —á–∏—Å–ª–æ - –≤–µ—Å –º–∏–Ω–∏–º–∞–ª—å–Ω–æ–≥–æ –æ—Å—Ç–æ–≤–Ω–æ–≥–æ –¥–µ—Ä–µ–≤–∞.

 | in   | out |
 |------|-----|
 |4 4   | 7   |
 |1 2 1 |     |
 |2 3 2 |     |
 |3 4 5 |     |
 |4 1 4 |     |

****************************************************************************/

#include <vector>
#include <set>
#include <list>
#include <iostream>


/**********************USED***************************/

using std::vector;
using std::list;
using std::pair;
using std::make_pair;
using std::set;
using std::swap;

const unsigned INFINITY = 4294967295;

typedef pair<unsigned, unsigned> pair_uu;


/*********************GRAPH***************************/

class Graph {
public:
    Graph(unsigned verticesNumber);

    void addEdge(unsigned from, unsigned to, unsigned weight);

    // –í–µ—Ä—à–∏–Ω—ã - –≤–µ–∫—Ç–æ—Ä –ø–∞—Ä <vertex, weight>
    void getRelated(unsigned vertex, vector<pair_uu> &vertices) const;

    unsigned getSize() const;

private:
    unsigned size_;
    vector<list<pair_uu>> edges_;
};

/*********************GRAPH***************************/

Graph::Graph(unsigned int size) :
        size_(size),
        edges_(size_, list<pair_uu>())
{}


void Graph::addEdge(unsigned from, unsigned to, unsigned weight)
{
    edges_[from].push_back(make_pair(to, weight));
    edges_[to].push_back(make_pair(from, weight));
}


unsigned Graph::getSize() const
{
    return size_;
}


void Graph::getRelated(unsigned vertex,
                                     vector<pair_uu> &vertices) const
{
    vertices.clear();
    for(const pair_uu & i : edges_[vertex])
        vertices.push_back(i);
}



/***********************PRIMS*************************/

unsigned MSTWeight(const Graph & graph){
    // –°—Ç–æ—Ä–∏–º –º–∞—Å—Å–∏–≤ —Å –º–∏–Ω–∏–º–∞–ª—å–Ω—ã–º–∏ –≤–µ—Å–∞–º–∏ —Ä–µ–±–µ—Ä –æ—Ç used –¥–æ unused –¥–ª—è i-–æ–π –≤–µ—Ä—à–∏–Ω—ã
    vector<unsigned> key(graph.getSize(), INFINITY);
    // i-–∞—è –≤–µ—Ä—à–∏–Ω–∞ –±—ã–ª–∞ –≤ MST => true
    vector<bool> used(graph.getSize(), false);
    // –û—á–µ—Ä–µ–¥—å —Å –ø—Ä–∏–æ—Ä–∏—Ç–µ—Ç–æ–º
    set<pair_uu> queue;


    key[0] = 0;
    for (size_t i = 0; i < graph.getSize(); ++i)
        queue.emplace(make_pair(key[i], i));

    // Prim's algor
    while (!queue.empty()) {
        // –ë–µ—Ä–µ–º –º–∏–Ω–∏–º—É–º
        unsigned cur_vertex = queue.begin()->second;
        queue.erase(queue.begin());
        used[cur_vertex] = true;
        // –†–µ–ª–∞–∫—Å–∞–∫—Ü–∏—è —Å–≤—è–∑–∞–Ω–Ω—ã—Ö –≤–µ—Ä—à–∏–Ω
        vector<pair_uu> related;
        graph.getRelated(cur_vertex, related);

        for (const pair_uu & u : related) {
            if (!used[u.first] && key[u.first] > u.second) {
                //–ú–µ–Ω—å—à–∏–π –∫–ª—é—á
                queue.erase(queue.find(make_pair(key[u.first], u.first)));
                key[u.first] = u.second;
                queue.emplace(key[u.first], u.first);
            }
        }
    }

    // –°—Ç—Ä–æ–∏–º –æ—Ç–≤–µ—Ç. Key —Ö—Ä–∞–Ω–∏—Ç –≤–µ—Å–∞ —Ä–µ–±–µ—Ä –≤ MST
    unsigned answer = 0;
    for(unsigned weigth : key){
        answer += weigth;
    }
    return answer;
}


/************************MAIN*************************/

int main()
{
    unsigned n = 0;
    unsigned m = 0;
    std::cin >> n >> m;
    Graph graph(n);
    for(unsigned i = 0; i < m; ++i) {
        unsigned a = 0;
        unsigned b = 0;
        unsigned w = 0;
        std::cin  >> a >> b >> w;
        graph.addEdge(a - 1, b - 1, w);
    }

     std::cout << MSTWeight(graph);

     return 0;
}


